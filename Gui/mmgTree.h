/*=========================================================================
  Program:   Multimod Application Framework
  Module:    $RCSfile: mmgTree.h,v $
  Language:  C++
  Date:      $Date: 2005-04-12 14:02:35 $
  Version:   $Revision: 1.5 $
  Authors:   Silvano Imboden
==========================================================================
  Copyright (c) 2002/2004
  CINECA - Interuniversity Consortium (www.cineca.it) 
=========================================================================*/
#ifndef __mmgTree_H__
#define __mmgTree_H__
//----------------------------------------------------------------------------
// Include:
//----------------------------------------------------------------------------
#include <wx/laywin.h>
#include <wx/image.h>
#include <wx/imaglist.h>
#include <wx/treectrl.h>
#include <wx/hash.h>
#include "mafEvent.h"
#include "mmgNamedPanel.h"

//----------------------------------------------------------------------------
// const :
//----------------------------------------------------------------------------
const int ID_TREE = 200;
//----------------------------------------------------------------------------
// mmgTree :
//----------------------------------------------------------------------------
/**
mmgTree allows a simplified and lot easier use of a wxWindows tree widget. 
- Nodes have id, parent, label and icon.
- Nodes can be added and deleted
- Parent,label and icon can be changed.
- Delete or reparent a node affect its whole subtree.
- mmgTree doesn't assume anything about the nodes represented, thus nodes objects may be everything. 
  Nodes are referenced by a node_id of type long, so a node_id may be a numeric value or a pointer.
- mmgTree doesn't use the wxWindows event-system: to receive event notification provide 
  a mafEventListener object by calling SetListener.

  events generated by mmgTree:
- VME_SELECTED   node_id
- NODE_DESELECTED node_id (removed)

\par implementation details:
the term "Node" refer to the object represented in the Tree,
the term "Item" refer to the graphics object shown in the Tree.

Calling wxTreeCtrl::AddNode return an object of type wxTreeCtrlItem,
these objects are to be kept somewhere to be able to edit or delete the items later.
The easy solution is to store a pointer to wxTreeCtrlItem in the node,
but this will mean that mmgTree has some knowledge on the node objects 
thus making mmgTree non-general-pourpose  and also that
every node can be connected to one mmgTree only.

The solution adopted here is to store all the wxTreeCtrlItem in a HashTable (m_table)
indexed by the node_id's. Thus explicit conversion between node_ids and items has to be addressed.

ItemFromNode is implemented using m_table.Note that wxHashTable store only object 
of type mmgTreeTableElement so a new class mmgTreeTableItem was derived from wxHashTableItem
to store a pointer to wxTreeCtrlItem

NodeFromItem may be implemented searching all the elements in m_table but this
will be time-consuming, another solution is to store the node_id in the item.
Items may store user-data in a class derived from wxTreeItemData, so a class mmgTreeItemData
was created for this pourpose. A new mmgTreeItemData object is created every time 
an item is inserted in the tree.

Further aspect:
One Item may have a cross-icon that mean that it has children and thus can be opened,
to show the cross-icon the developer must call SetItemHasChildren.
wxTreeCtrl doesn't set-up the HasChildren flag itself, so when a node is added or deleted the 
HasChildren flag of the parent has to be kept consistent.Another flag control if 
a subtree is expanded or collapsed, this flag has to be kept consistent when moving a node.
  
Moving a node:
wxTreeCtrl doesn't provide a way to change item's parent, so that operation has to be implemented
explicitly. Delete and recreate the item doesn't work because delete the item destroy
all the items in the subtree.The correct approach is to copy the item under the new parent,
recursively move all the item in the subtree, and then delete the old item.During this operation 
the HasChildren flag, the IsExpanded flag and the HashTable contents has to be kept consistent.

Deleting a node:
Deleting an item destroy all the sub-items,leaving the m_table inconsistent.
To correctly implement the operation, DeleteNode must call itself recursively on the 
item subtree, then Delete the item and remove the corresponding m_table entry. 
*/
class mmgTree: public mmgNamedPanel
{
public:
                 mmgTree (wxWindow* parent, wxWindowID id=-1, bool CloseButton = false, bool HideTitle = false); 
  virtual       ~mmgTree();

  /** Clears all items in the tree. */
	void Reset();
  
	/** Create a new tree item with the specified parent,label and icon. 
      Set parent = 0 to create the root. 0 is not a valid node_id.
  */
	bool AddNode(long node_id, long parent_id , wxString label, int icon = 0);
  
	/** Delete the specified node, and its subtree. */
	bool DeleteNode(long node_id);
  
	/** Set the label for the node. */
	bool SetNodeLabel(long node_id, wxString label);
  
	/** Move a node, and its subtree. */
	bool SetNodeParent(long node_id, long parent_id );
  
	/** Set the icon for the node. */
  bool SetNodeIcon(long node_id, int icon);
  
  /** Return the icon index for the node 'node_id'. */
  int  GetNodeIcon(long node_id);

  /** Select the node. */
  bool SelectNode(long node_id);

  /** Set the images to be used for the nodes. 
      Must be set before adding any node. 
      The default ImageList provide 4 icons :
      -1 gray dot 
      -2 red dot 
      -3 blue dot 
      -4 yellow dot 
  */
  void SetImageList(wxImageList *img);

  /** Sort the children of node_id. (not the subtree) 
      give node_id = 0 to specify the root. */
  void SortChildren(long node_id =0);

  /** if autosort is on - the tree is always kept sorted */
  void SetAutoSort(bool enable) {m_autosort=enable;};

  /** collapse the children of node_id */
  void CollapseNode(long node_id);

  /** expand the children of node_id */
  void ExpandNode(long node_id);

  /** Set the Listener that will receive event-notification, the Listener can be changed any time  */
  void SetListener(mafEventListener *listener)   {m_Listener=listener;}; 

protected:
  /** Private function that notify the Listener of node selection and deselection. */
  virtual void OnSelectionChanged(wxTreeEvent& event);
  
	/** When tree is used on a wxNotebook m_tree must be called on Sizing . */
  void OnSize(wxSizeEvent& event);

	/** Return true if node exist. */
  bool NodeExist(long node_id);
  
	/** Return the node item from node id. */
  wxTreeItemId ItemFromNode(long node_id);
  
	/** Return node id from node item. */
  long NodeFromItem(wxTreeItemId& item);
  
	/** Delete recursively a node and its subtree. */
	void DeleteNode2(long node_id);
  
	/** Move a node, and its subtree. */
  void SetNodeParent2(long node_id, long parent_id );
    
  /** Check that id is a valid index in the imagelist - return the (eventually clamped) value */
  int CheckIconId(int icon);

  bool               m_prevent_notify;
  bool               m_autosort;
  long               m_root;
  wxTreeCtrl        *m_tree;         
  wxImageList       *m_images;       
  wxHashTable       *m_table;        
  mafEventListener  *m_Listener;     

	//----------------------------------------------------------------------------
	// mmgTreeItemData :
	/// Data to be attached to an item of mmgTree, holds the reference to a node_id 
	//----------------------------------------------------------------------------
	class mmgTreeItemData: public wxTreeItemData{
	public:
			mmgTreeItemData(long node_id) {m_node_id = node_id; };
			long GetNode()                {return m_node_id;};
	protected:
			long m_node_id;
	};
	//----------------------------------------------------------------------------
	// mmgTreeTableElement:
	/// specialized HashTable element used in mmgTree to store a reference to a wxTreeItemId 
	//----------------------------------------------------------------------------
	class mmgTreeTableElement: public wxObject
	{
	public:
	  mmgTreeTableElement(wxTreeItemId item) {m_item=item;  };
		wxTreeItemId GetItem()                 {return m_item;};
		void SetItem(wxTreeItemId item){m_item=item;  };
	protected:
		wxTreeItemId m_item;          
	};

DECLARE_EVENT_TABLE()
}; // end of mmgTree
#endif
